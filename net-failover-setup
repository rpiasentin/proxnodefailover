#!/usr/bin/env bash
set -euo pipefail

VERSION="1.0.1"

log(){ echo "[$(date -Is)] $*"; }
die(){ echo "ERROR: $*" >&2; exit 1; }

need_root() { [[ "${EUID:-$(id -u)}" -eq 0 ]] || die "Run as root."; }
have_cmd(){ command -v "$1" >/dev/null 2>&1; }

prompt() {
  local q="$1" d="$2" __var="$3" a=""
  if [[ "${NONINTERACTIVE:-0}" == "1" ]]; then
    printf -v "$__var" "%s" "$d"
    return 0
  fi
  read -r -p "${q} [${d}]: " a
  a="${a:-$d}"
  printf -v "$__var" "%s" "$a"
}

prompt_secret() {
  local q="$1" d="$2" __var="$3" a=""
  if [[ "${NONINTERACTIVE:-0}" == "1" ]]; then
    printf -v "$__var" "%s" "$d"
    return 0
  fi
  read -r -s -p "${q} [${d}]: " a
  echo
  a="${a:-$d}"
  printf -v "$__var" "%s" "$a"
}

yesno() {
  local q="$1" d="$2" __var="$3" a=""
  if [[ "${NONINTERACTIVE:-0}" == "1" ]]; then
    printf -v "$__var" "%s" "$d"
    return 0
  fi
  read -r -p "${q} [${d}]: " a
  a="${a:-$d}"
  a="$(echo "$a" | tr '[:lower:]' '[:upper:]')"
  [[ "$a" == "Y" || "$a" == "YES" ]] && a="Y" || a="N"
  printf -v "$__var" "%s" "$a"
}

ts_backup() {
  local f="$1"
  [[ -e "$f" ]] || return 0
  local ts; ts="$(date +%Y%m%d-%H%M%S)"
  cp -a "$f" "${f}.bak.${ts}"
  log "Backed up $f -> ${f}.bak.${ts}"
}

detect_vmbr() {
  if ip link show vmbr0 >/dev/null 2>&1; then echo "vmbr0"; return 0; fi
  ls /sys/class/net 2>/dev/null | grep -E '^vmbr' | head -n1 || true
}

detect_bridge_port() {
  local br="$1"
  if [[ -d "/sys/class/net/${br}/brif" ]]; then
    ls "/sys/class/net/${br}/brif" 2>/dev/null | head -n1 || true
  else
    echo ""
  fi
}

detect_wifi() { ls /sys/class/net 2>/dev/null | grep -E '^wl' | head -n1 || true; }

current_default_gw() { ip route show default 2>/dev/null | awk 'NR==1{print $3}' || true; }

current_ip_cidr() {
  local ifc="$1"
  ip -4 -o addr show dev "$ifc" 2>/dev/null | awk '{print $4}' | head -n1 || true
}

usage() {
  cat <<USAGE
net-failover-setup v$VERSION

Usage: $0 [--dry-run] [--non-interactive] [--write-only]

Options:
  --dry-run          Show detected values & plan, do not write anything.
  --non-interactive  Use defaults (or env vars) without prompting.
  --write-only       Write files and systemd unit, but DO NOT enable/start the service.

Env overrides:
  NONINTERACTIVE=1
  MGMT_IF=vmbr0
  ETH_LINK_IF=nic0
  WIFI_IF=wlp2s0
  STATIC_CIDR=192.168.1.127/24
  STATIC_GW=192.168.1.1
  FALLBACK_CIDR=192.168.99.1/24
  WIFI_SSID=Piahas
  WIFI_PSK=richardpiasentin
  CHECK_INTERVAL=10
  DO_TAILSCALE=Y|N
  TS_AUTHKEY=tskey-...

Examples:
  $0 --write-only
  systemctl enable --now net-failover.service
USAGE
}

show_plan() {
  cat <<PLAN

--- net-failover setup plan (v$VERSION) ---
WRITE_ONLY       = $WRITE_ONLY
MGMT_IF          = $MGMT_IF
ETH_LINK_IF      = $ETH_LINK_IF
WIFI_IF          = $WIFI_IF

STATIC_CIDR      = $STATIC_CIDR
STATIC_GW        = $STATIC_GW
FALLBACK_CIDR    = $FALLBACK_CIDR

WIFI_SSID        = $WIFI_SSID
WIFI_PSK         = (hidden)
CHECK_INTERVAL   = $CHECK_INTERVAL

Install Tailscale= $DO_TAILSCALE
TS_AUTHKEY       = $( [[ -n "${TS_AUTHKEY:-}" ]] && echo "provided" || echo "not provided" )

Files to write/update:
- /etc/net-failover.conf
- /usr/local/sbin/net-failover.sh
- /etc/systemd/system/net-failover.service
------------------------------------------
PLAN
}

install_packages() {
  log "Installing required packages..."
  apt-get update -y
  apt-get install -y isc-dhcp-client wpasupplicant iw curl ca-certificates
}

install_tailscale_optional() {
  [[ "$DO_TAILSCALE" == "Y" ]] || return 0

  if ! have_cmd tailscale; then
    log "Installing Tailscale..."
    curl -fsSL https://tailscale.com/install.sh | sh
  else
    log "Tailscale already installed."
  fi

  systemctl enable --now tailscaled >/dev/null 2>&1 || true

  if [[ -n "${TS_AUTHKEY:-}" ]]; then
    log "Bringing up Tailscale with authkey + SSH..."
    tailscale up --authkey="${TS_AUTHKEY}" --ssh || true
  else
    log "Bringing up Tailscale with SSH (may print an auth URL if not already authenticated)..."
    tailscale up --ssh || true
  fi

  log "Tailscale status (self):"
  tailscale status --self 2>/dev/null || true
}

write_conf() {
  ts_backup /etc/net-failover.conf
  cat >/etc/net-failover.conf <<CONF
# Generated by net-failover-setup v$VERSION on $(date -Is)

MGMT_IF="$MGMT_IF"
ETH_LINK_IF="$ETH_LINK_IF"
WIFI_IF="$WIFI_IF"

STATIC_CIDR="$STATIC_CIDR"
STATIC_GW="$STATIC_GW"
FALLBACK_CIDR="$FALLBACK_CIDR"

WIFI_SSID="$WIFI_SSID"
WIFI_PSK="$WIFI_PSK"

CHECK_INTERVAL="$CHECK_INTERVAL"
CONF
  chmod 600 /etc/net-failover.conf
  log "Wrote /etc/net-failover.conf (mode 600)."
}

write_runtime() {
  ts_backup /usr/local/sbin/net-failover.sh
  cat >/usr/local/sbin/net-failover.sh <<'RUNTIME'
$(cat /mnt/data/proxnodefailover/scripts/net-failover.sh)
RUNTIME
  chmod +x /usr/local/sbin/net-failover.sh
  log "Wrote /usr/local/sbin/net-failover.sh"
}

write_service() {
  ts_backup /etc/systemd/system/net-failover.service
  cat >/etc/systemd/system/net-failover.service <<'UNIT'
[Unit]
Description=Proxmox network failover (wired static -> wired dhcp -> wifi -> direct)
After=network-pre.target tailscaled.service
Wants=network-pre.target

[Service]
Type=simple
ExecStart=/usr/local/sbin/net-failover.sh
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
UNIT

  systemctl daemon-reload

  if [[ "$WRITE_ONLY" == "1" ]]; then
    log "WRITE-ONLY: service installed but NOT enabled/started."
    log "To start later: systemctl enable --now net-failover.service"
  else
    if [[ -n "${SSH_CONNECTION:-}" ]]; then
      log "NOTE: SSH detected. Starting the service can change routes/IPs."
      log "If you want safer behavior, re-run with --write-only."
    fi
    systemctl enable --now net-failover.service
    log "Enabled+started net-failover.service"
  fi
}

verify() {
  log "Verification snapshot:"
  echo "---- ip -br link ----"
  ip -br link || true
  echo "---- ip -4 -br addr ----"
  ip -4 -br addr || true
  echo "---- carrier ----"
  [[ -n "${ETH_LINK_IF:-}" ]] && { echo -n "$ETH_LINK_IF carrier: "; cat "/sys/class/net/${ETH_LINK_IF}/carrier" 2>/dev/null || true; }
  echo "---- pveproxy 8006 ----"
  ss -lntp | grep 8006 || true

  if systemctl is-enabled net-failover.service >/dev/null 2>&1; then
    echo "---- net-failover enabled ----"
    systemctl is-enabled net-failover.service || true
  else
    echo "---- net-failover enabled ----"
    echo "disabled"
  fi

  if systemctl is-active net-failover.service >/dev/null 2>&1; then
    echo "---- net-failover logs (last 30) ----"
    journalctl -u net-failover.service -n 30 --no-pager || true
  else
    echo "---- net-failover logs ----"
    echo "(service not active)"
  fi
  echo "-------------------------------------"
}

DRYRUN=0
WRITE_ONLY=0
NONINTERACTIVE="${NONINTERACTIVE:-0}"

for arg in "${@:-}"; do
  case "$arg" in
    --dry-run) DRYRUN=1 ;;
    --write-only) WRITE_ONLY=1 ;;
    --non-interactive) NONINTERACTIVE=1 ;;
    -h|--help) usage; exit 0 ;;
    *) die "Unknown argument: $arg" ;;
  esac
done

need_root

MGMT_IF="${MGMT_IF:-$(detect_vmbr)}"
WIFI_IF="${WIFI_IF:-$(detect_wifi)}"

if [[ -z "${MGMT_IF:-}" ]]; then
  log "Could not detect a vmbr* bridge."
  log "Available interfaces:"
  ip -br link | awk '{print " - " $1}'
  MGMT_IF="vmbr0"
fi

ETH_LINK_IF="${ETH_LINK_IF:-$(detect_bridge_port "$MGMT_IF")}" 

DEFAULT_STATIC_CIDR="$(current_ip_cidr "$MGMT_IF")"
DEFAULT_STATIC_CIDR="${DEFAULT_STATIC_CIDR:-192.168.1.127/24}"
DEFAULT_GW="$(current_default_gw)"
DEFAULT_GW="${DEFAULT_GW:-192.168.1.1}"

STATIC_CIDR="${STATIC_CIDR:-$DEFAULT_STATIC_CIDR}"
STATIC_GW="${STATIC_GW:-$DEFAULT_GW}"
FALLBACK_CIDR="${FALLBACK_CIDR:-192.168.99.1/24}"

WIFI_SSID="${WIFI_SSID:-Piahas}"
WIFI_PSK="${WIFI_PSK:-richardpiasentin}"
CHECK_INTERVAL="${CHECK_INTERVAL:-10}"

DO_TAILSCALE="${DO_TAILSCALE:-Y}"
TS_AUTHKEY="${TS_AUTHKEY:-}"

prompt "MGMT interface (Proxmox mgmt IP; typically vmbr0)" "$MGMT_IF" MGMT_IF

if [[ -d "/sys/class/net/${MGMT_IF}/brif" ]]; then
  BRPORTS="$(ls "/sys/class/net/${MGMT_IF}/brif" 2>/dev/null | tr '\n' ' ' || true)"
  log "Bridge ports for $MGMT_IF: ${BRPORTS:-none}"
fi
prompt "Physical Ethernet interface for carrier detection (bridge port; e.g., nic0)" "${ETH_LINK_IF:-nic0}" ETH_LINK_IF
prompt "Wi-Fi interface" "${WIFI_IF:-wlp2s0}" WIFI_IF

prompt "Preferred WIRED static CIDR" "$STATIC_CIDR" STATIC_CIDR
prompt "Preferred WIRED static gateway" "$STATIC_GW" STATIC_GW
prompt "DIRECT-connect fallback CIDR (no GW)" "$FALLBACK_CIDR" FALLBACK_CIDR

prompt "Wi-Fi SSID" "$WIFI_SSID" WIFI_SSID
prompt_secret "Wi-Fi password/PSK" "$WIFI_PSK" WIFI_PSK

prompt "Health check interval (seconds)" "$CHECK_INTERVAL" CHECK_INTERVAL

yesno "Install/enable Tailscale + Tailscale SSH on this node?" "$DO_TAILSCALE" DO_TAILSCALE

if [[ "$DO_TAILSCALE" == "Y" && "${NONINTERACTIVE}" == "0" ]]; then
  read -r -p "Optional: paste Tailscale authkey (leave blank for interactive login URL): " local_ans
  TS_AUTHKEY="${local_ans:-$TS_AUTHKEY}"
fi

show_plan

if [[ "$DRYRUN" == "1" ]]; then
  log "--dry-run set; exiting without changes."
  exit 0
fi

install_packages
install_tailscale_optional
write_conf
write_runtime
write_service
verify

log "Done."
if [[ "$WRITE_ONLY" == "1" ]]; then
  log "Next step when ready: systemctl enable --now net-failover.service"
else
  log "Service running: systemctl status net-failover.service"
fi
